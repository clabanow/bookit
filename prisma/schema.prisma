// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

// ============================================
// Authentication & Account Models
// ============================================

/// User role determines permissions
enum Role {
  USER   // Regular user, can host and play
  ADMIN  // Can approve users and manage system
}

/// User approval status
enum ApprovalStatus {
  PENDING   // Waiting for admin approval
  APPROVED  // Can login and use the system
  REJECTED  // Admin rejected the registration
}

/// User account - the login identity
/// Each user can have up to 3 Player sub-accounts
model User {
  id           String         @id @default(cuid())
  email        String         @unique
  passwordHash String?        // Nullable for OAuth-only users
  googleId     String?        @unique // Google's unique user ID for OAuth
  role         Role           @default(USER)
  status       ApprovalStatus @default(PENDING)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  // Relations
  players      Player[]       // Up to 3 player sub-accounts
  questionSets QuestionSet[]  // Question sets owned by this user
}

/// Player sub-account - the identity used in games
/// Each user can have up to 3 players (e.g., for family members)
/// Each player has a secret PIN to prevent siblings from using the wrong account
model Player {
  id        String   @id @default(cuid())
  userId    String
  nickname  String
  pinHash   String   // 4-digit secret PIN (hashed for security)
  avatar    String?  // Optional avatar URL for future use
  coins     Int      @default(0) // Gold coins earned from gameplay
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  ownedCards PlayerCard[] // Cards this player has purchased
  gamePlays  GamePlay[]   // Game history for anti-farming tracking

  @@index([userId])
}

// ============================================
// Game Content Models
// ============================================

/// Question type determines how the question is displayed and answered
enum QuestionType {
  MULTIPLE_CHOICE  // Traditional 4-option selection
  SPELLING         // Word is spoken, player types the spelling
}

model QuestionSet {
  id        String     @id @default(cuid())
  title     String
  ownerId   String?    // Links to User.id
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  questions Question[]
  owner     User?      @relation(fields: [ownerId], references: [id], onDelete: SetNull)

  @@index([ownerId])
}

model Question {
  id           String       @id @default(cuid())
  setId        String
  questionType QuestionType @default(MULTIPLE_CHOICE)
  prompt       String       // For MC: the question text. For spelling: the word to spell
  options      String[]     // Array of 4 options (only for MULTIPLE_CHOICE)
  correctIndex Int          // 0-3 for MC, ignored for spelling
  answer       String?      // The correct spelling (only for SPELLING type)
  hint         String?      // Optional hint for spelling (e.g., "It's a color")
  timeLimitSec Int          @default(20)
  order        Int          @default(0)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  questionSet  QuestionSet  @relation(fields: [setId], references: [id], onDelete: Cascade)

  @@index([setId])
}

// ============================================
// Coins & Trading Cards Models
// ============================================

/// Card rarity tiers — determines visual style and coin cost
enum CardRarity {
  COMMON      // 50 coins
  RARE        // 200 coins
  LEGENDARY   // 500 coins
  MYSTICAL    // 1,500 coins
  IRIDESCENT  // 5,000 coins
}

/// A collectible trading card in the catalog
model Card {
  id          String     @id @default(cuid())
  name        String     @unique // e.g., "Cat", "Pumpkin Puppy"
  description String     // Flavor text for the card
  rarity      CardRarity
  coinCost    Int        // How many coins to buy this card
  imageUrl    String?    // Card art (future use)
  season      String?    // null = always available, "OCT" / "NOV" / "DEC" = seasonal
  createdAt   DateTime   @default(now())

  // Relations
  owners      PlayerCard[]
}

/// Join table: which players own which cards
model PlayerCard {
  id         String   @id @default(cuid())
  playerId   String
  cardId     String
  obtainedAt DateTime @default(now())

  // Relations
  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  card       Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)

  @@unique([playerId, cardId]) // A player can only own each card once
  @@index([playerId])
  @@index([cardId])
}

/// Tracks each game a player completes — used for anti-farming coin reduction
model GamePlay {
  id             String   @id @default(cuid())
  playerId       String
  questionSetId  String
  coinsEarned    Int      // Coins earned in this game (after multiplier)
  playedAt       DateTime @default(now())

  // Relations
  player         Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([playerId, questionSetId]) // For quickly checking repeat plays
}
